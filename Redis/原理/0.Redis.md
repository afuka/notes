## 一、数据结构

全局哈希表，（哈希表 -> 哈希桶 -> 键值对数据 -> 具体值的指针）

【string】动态字符串

【list】双向链表、压缩表

【hash】哈希表、压缩表

【sort set】跳表、压缩表

【set】数组、哈希表



查询效率

- 单元素操作是基础；
- 范围操作非常耗时；
- 统计操作通常高效；
- 例外情况只有几个。

压缩列表和双向链表都会记录表头和表尾的偏移量。这样一来，对于 List 类型的 LPOP、RPOP、LPUSH、RPUSH 这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有 O(1)，可以实现快速操作。

## 二、rehash机制

为了解决哈希冲突，又不阻塞线程影响效率，采用**渐进式rehash**

Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。

- 给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；
- Redis每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；
- 等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。
- 释放哈希表 1 的空间。



## 三、单线程 Redis 快速的原因

- 操作在内存上完成
- 高效的数据结构
- 多路复用机制，基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数



## 四、AOF日志

文本形式保存的。

Redis 是**先执行命令，把数据写入内存**。**避免出现记录错误**；**不会阻塞当前的写操作**。

AOF三种写回策略，Always，同步写回；Everysec，每秒写回；No，操作系统控制的写回。

AOF 重写机制避免AOF日志文件过大。“一个拷贝，两处日志”，不会阻塞主线程



## 五、RDB快照

和 AOF 相比，RDB 记录的是某一时刻的数据，并不是操作，所以，在做数据恢复时，我们可以直接把 RDB 文件读入内存，很快地完成恢复。

Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。save：在主线程中执行，会导致阻塞；bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。

Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。

可以使用增量快照解决**频繁地执行全量快照，带来的磁盘写入、创建子线程的两方面的开销。**

Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照



## 六、主从同步

第一次同步三个阶段

- 第一阶段，从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了。

- 第二阶段，主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。

- 第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。



如果从库实例过多，采用“主-从-从”模式部署



一旦主从库完成了全量复制，它们之间就会一直维护一个网络连接，主库会通过这个连接将后续陆续收到的命令操作再同步给从库，这个过程也称为**基于长连接的命令传播**，可以避免频繁建立连接的开销。



## 七、哨兵

哨兵其实就是一个运行在特殊模式下的 Redis 进程，哨兵主要负责的就是三个任务：监控、选主（选择主库）和通知。

一、监控

- “主观下线”：使用 PING 命令检测它自己和主、从库的网络连接情况，失败就是主观下线

- “客观下线”：当有 N 个哨兵实例时，最好要有 N/2 + 1 个实例判断主库为“主观下线”，才能最终判定主库为“客观下线”。



二、选主，从库优先级、从库复制进度以及从库 ID 号来进行筛选



## 八、切片集群

Redis Cluster 方案采用哈希槽，来处理数据和实例之间的映射关系。做分布式存储。

分配哈希槽时，需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作



当切片服务器新加机器的时候如果访问会重定向

- 数据同步完的情况下MOVE：给客户端返回下面的 MOVED 命令响应结果，这个结果中就包含了新实例的访问地址。
- 数据未同步完情况下ASK：把客户端所请求数据的最新实例地址返回给客户端，不会更新客户端缓存的哈希槽分配信息

