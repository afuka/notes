首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：

- 互斥性。在任意时刻，只有一个客户端能持有锁。
- 不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。
- 具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。
- 锁归属标识。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。

# 单机锁

## PHP实现加锁

```
// 参数解释 ↓
// $key 锁名称
// $value 加锁的客户端请求标识, 必须保证在所有获取锁清秋的客户端里保持唯一, 满足上面的第3个条件: 加锁/解锁的是同一客户端
// "NX" 仅在key不存在时加锁, 满足条件1: 互斥型
// "EX" 设置锁过期时间, 满足条件2: 避免死锁
$redis->set($key, $value, ["NX", "EX" => $expire])
```



## PHP借助lua脚本解锁

```
$key = "...";
$identification = "...";
// KEYS 和 ARGV 是lua脚本中的全局变量
$script = <<< EOF
if redis.call("get", KEYS[1]) == ARGV[1] then
    return redis.call("del", KEYS[1])
else
    return 0
end
EOF;
# $result = $redis->eval($script, [$key, $identification], 1);
// 返回结果 >0 表示解锁成功
// php中参数的传递顺序与标准不一样, 注意区分
// 第2个参数表示传入的 KEYS 和 ARGV, 通过第3个参数来区分, KEYS 在前, ARGV 在后
// 第3个参数表示传入的 KEYS 的个数
$result = $redis->evaluate($script, [$key, $identification], 1);
```



使用Lua脚本的原因:

- 避免误删其他客户端加的锁

  > eg. 某个客户端获取锁后做其他操作过久导致锁被自动释放, 这时候要避免这个客户端删除已经被其他客户端获取的锁, 这就用到了锁的标识.

- lua 脚本中执行 `get` 和 `del` 是原子性的, 整个lua脚本会被当做一条命令来执行

- 即使 `get` 后锁刚好过期, 此时也不会被其他客户端加锁

> eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令。
>
> 由于 script 执行的原子性, 所以不要在script中执行过长开销的程序，否则会验证影响其它请求的执行。



解锁容易错误的点:

- 直接`del`删除键

  原因: 可能移除掉其他客户端加的锁(在自己的锁已过期情况下)

- `get`判断锁归属, 若符合再`del`

  原因: 非原子性操作, 若在 `get` 后锁过期了, 此时别的客户端进行加锁操作, 这里的 `del` 就会错误的将其他客户端加的锁解开.



### Redis 中使用 Lua 脚本的注意点

- Redis 会把**所有执行过的脚本都缓存在内存中**
- Redis 在**重启**的时候会**释放掉**之前保存的脚本
- Lua 脚本中所需要用到的键名以及参数一定要使用 KEYS 和 ARGV 来替换，因为 **Redis 每次使用 script 都会校验脚本缓存中是否已存在相同脚本，否则就会存储到缓存中**，如果脚本很长，且每次请求存在不同的变量值，则会生成无数多个脚本缓存，占用内存。
- 通过 eval 带入的 **ARGV 参数如果原来是数字的，会被转换为字符串**，如果你的逻辑中需要判断该变量 > 0 或 < 0 之类的数字判断则必须进行字符串到数字的转换，使用 `tonumber()` 方法` if (tonumber(ARGV[1]) > 0) then return 1; end;`



# 集群锁

官方给出了一个 **RedLock** 算法 https://github.com/antirez/redis-doc/blob/master/topics/distlock.md【中文：http://ifeve.com/redis-lock/】

情景: 当前有N个完全独立的Redis master节点, 分别部署在不同的主机上

客户端获取锁的操作:

- 使用相同key和唯一值(作为value)同时向这N个redis节点请求锁, 锁的超时时间应该 >> 超时时间(考虑到请求耗时), 若某个节点阻塞了了应尽快跳过

- 计算步骤1消耗的时间, 若总消耗时间超过超时时间, 则认为锁失败. 客户端需在大多数(超过一半)的节点上成功获取锁, 才认为是锁成功.

- 如果锁成功了, 则该锁有效时间就是 锁原始有效时间 - 步骤1消耗的时间

- 如果锁失败了(超时或无法获取超过一半 N/2 + 1 实例的锁), 客户端会到每个节点释放锁(是每个, 即使之前认为加锁失败的节点)

