## 一、数组
数组是同一种数据类型元素的集合，在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组的大小不可变化，基本语法如下，数组的长度必须为常量，并且长度是数组类型的一部分
注意：数组是值类型的，支持 "==", "!="的操作，因为内存总是被初始化过的；[n]*T表示指针数组，*[n]T 表示数组指针
```
var a [3]int // 定义一个长度为3元素类型为int的数组
a := [3]int{1,2,3} // 初始化其中数
b := [...]int{1,2,3,4,5} // 数组长度按照初始化进去的变量来自动推算多少
c := [5]int{1,2} // 其余的会用0补
c := [5]int{0:1,4:2} // 根据索引初始化
```

### 1. 数组的遍历
```
citys := [...]string{"北京", "上海", "深圳"}
for i := 0; i < len(citys); i++ {
	fmt.Print(citys[i])
}
for i, v := range citys {
	fmt.Print(citys[i])
}
```

### 2. 多维数组
在此只以二维数组为例，还会有跟多维的
```
var a [3][2]int
// 初始化
a = [3][2]int{
	[2]int{1,2},
	[2]int{1,2},
	[2]int{1,2},
}
```

## 二、切片
因为数组的长度是固定的，并且数组长度属于类型的一部分，所以数组有很多局限性
切片是一个拥有相同类型元素的可变长度的序列。他是基于数组类型做的一层封装，非常灵活，支持自动扩容，切片是一个引用类型，他的内部结构包含地址、长度和容量。切片一般用于快速的操作一块数据集合
注意：切片是不能直接比较的，因为是引用类型；切片唯一合法比较操作是那个nil比较，一个nil值的切片并没有底层数组，一个nil值的切片的长度和容量都是0，但是我们不能说一个长度和容量都是0的切片一定是nil
```
var name []int // 没有长度就成了切片, 初始化和数组是一样
// 由数组得到切片
a := [5]int{1,2,3,4,5}
b := a[0:4] // 基于数组切割，左闭右开[)
c := a[0:]
d := a[:4]
e := a[:]
f = e[:4] // 切片可以再切
```
切片有自己的长度和容量，len()是求长度，cap() 是求容量
切片只想了一个底层的数组
切片的长度就是元素的个数
切片的容量是底层数组从切片的第一个元素到最后一个元素的数量

### 1. make 函数创建切片
```
make([]类型, 元素数量, 切片容量)

```
### 2. 切片的赋值拷贝
拷贝前后两个变量，共享底层数组，对一个切片的修改会影响另一个切片的内容，需要特别注意
```
s1 := []int{1,2,3}
s2 := s1
s2[0] = 1000 // 这个操作会使s1和s2 的第一项都变成1000
```
### 3. 切片的操作
```
# append方法为切片添加元素
s1 := []int{1,2,3}
s1 = append(s1, 4) // 调用append函数必须用原来的切片变量接受返回值
s1 = append(s1, 4, 5) // 添加多项 
s2 := []int{5,6,7}
s1 = append(s1, s2...) // ... 表示拆开
# copy 方法进行切片的复制
s1 := []int{1,2,3}
var s2 = make([]int, 3, 3) // 注意如果 是nil 是拷贝不进去的
copy(s2, s1)
# go 语言中没有删除切片元素的专用方法，可以使用切片本身特性来删除
s1 := []int{1,2,3}
s1 = append(a[:1], a[2:]...)
# 使用sort包，进行排序
s1 := []int{3,1,2, 9,7,5}
sort.Ints(s1)
```

## 三、Map
go语言提供映射关系容器为Map，其内部使用hash实现
map时一种无序的基于key-value的数据结构，go语言中map时引用类型，必须初始化才能使用
```
map[KeyType]ValueType
```
map 类型的变量默认初始为nil，需要使用make函数分配内存
```
make(map[KeyType]ValueType, [cap]) // 其中cap表示map的容量，虽不是必须的，但是我们应该初始化时候就制定一个合适的容量
```

### 1. map的基本使用
`dict := map[string]int{"张三":43,"李四":50}` 直接声明的话
```
func main() {
	scoreMap := make(map[string]int, 10)
	scoreMap["测试1"] = 18
	scoreMap["afuka"] = 20
	fmt.Print(scoreMap)
	fmt.Print(scoreMap["afuka"])
	fmt.Print(scoreMap["beyoung"]) // 如果不存在这个key，拿到对应值类型的零值
	// 判断是否存在key
	value, ok := scoreMap["beyoung"]
	if !ok {
		fmt.Print("不存在对应key值")
	} else {
		fmt.Print(value)
	}
}
```
### 2. 遍历
```
for k, v := range scoreMap {
	fmt.Print(k, "=", v)
}
```
### 3. 删除
使用delete函数从map删除一组键值对
```
delete(map, key) // map表示对应的map，key就是对应的键
```